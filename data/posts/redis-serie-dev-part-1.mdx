---
title: 'Mejorando los tiempo de respuesta de nuestras API con Redis y Go'
date: '2021-11-04'
tags:
  - 'üíª Development'
  - 'Redis'
  - 'Golang'
---



En este art√≠culo continuaremos haciendo uso de nuestra base de datos [Redis](https://redis.io/), pero a trav√©s del lenguaje de programci√≥n [golang](https://golang.org/). Durante estos pr√≥ximos art√≠culos estaremos explorando las bondades que nos ofrece esta base de datos.

Uno de los casos de usos mas frecuentes que solemos afrontar en nuestra activadad de desarrollo es como mejorar los tiempos de respuestas de nuestros servicios (***api*** ***servers*** o aplicaciones ***CLI***).

En el dia de hoy trabajaremos con el recurso [coingecko](https://www.coingecko.com/es/api/documentation) esta ***API*** nos permite consultar: listado de las mendas y precios, datos historicos, datos relacionados con los contratos inteligentes entre otras cosas todo esto y m√°s se pueden obeservar en su documentaci√≥n oficial al final del art√≠culo te compartir√© los enlaces. Esta API tiene implememtado `rate limit` üõë de  ` 50 calls/minute` y en este tutorial te ense√±ar√© a reducir el tiempo de respuesta al consultar la api y adem√°s a ahorrar la mayor cantidad de llamadas al API durante un minuto.

En este tutorial se asume que tenemos instalada la base de datos redis  y el lenguaje de progrmaci√≥n [*golang downloads site*](https://golang.org/doc/install)

### Configuraci√≥n inicial de nuestro proyecto

En este caso usaremos redis pero a trav√©s de [podman](https://podman.io/). El cual es un motor de contenedores como docker. M√°s detalles consultar la [documentaci√≥n oficial](https://podman.io/whatis.html).

```bash
# Download image
podman pull quay.io/bitnami/redis
# Run the container for our redis instance
podman run --name redis --rm -e ALLOW_EMPTY_PASSWORD=yes -p 6379:6379 quay.io/bitnami/redis:latest
```

Procedemos a inicializar nuestro proyecto siguiendo los siguientes pasos.

```bash

mkdir app
cd app

# init project using go mod
go mod init app

# install redis package
go get github.com/go-redis/redis/v8

touch main.go
```

Quedando as√≠ nuestro fichero `main.go` donde estaremos realizando toda la l√≥gica de nuestra aplicaci√≥n.

```go
package main

import "fmt"

func main() {
	fmt.Println("App to fetch all supported coins' id, name, and symbol")
}

```

### Pues comencemos con nuestra consulta a la API 

En nuestra consulta a la API trabajaremos con el recurso `/coins/list` el cual nos retorna un listado con todas las monedas soportadas por la API.

```bash
curl -X 'GET' \
  'https://api.coingecko.com/api/v3/coins/list' \
  -H 'accept: application/json'

```
Este listado es conformado por la siguiente respuesta json.
```json
[
  {
    "id": "01coin",
    "symbol": "zoc",
    "name": "01coin"
  },
  {
    "id": "0-5x-long-algorand-token",
    "symbol": "algohalf",
    "name": "0.5X Long Algorand Token"
  }
  ...
]
```

Teniendo como base inicial una muestra de la respuesta de nuestro *endpoint* `/coins/list` vamos a implementar una `struct` para nuestro tipo de dato `Coin` con las siguientes propiedades.

```go 
// Coin ...
type Coin struct {
	ID     string `json:"id"`
	Symbol string `json:"symbol"`
	Name   string `json:"name"`
}
...
```

Luego procedemos a crear las siguientes variables y `structs` con las que trabajaremos durante este tutorial

```go

var (
	urlBase          = "https://api.coingecko.com/api"
	urlVersion       = "v3"
	resourceCoinList = "coins/list"
)

// ResponseCoins ...
type ResponseCoins struct {
	Coins        []Coin `json:"coins,omitempty"`
	Source       string `json:"soure,omitempty"`
	ResponseTime string `json:"response_time,omitempty"`
}
```

Comencemos a consumir nuestra `api` en este caso go, nos provee un exelente `stdlib` con su paquete `net/http`. Con el cual crearemos nuestro m√©todo `getCoins` el cual recibe por parametros el `method` y el `endpoint` y retorna una estructura de tipo `ResponseCoin`

```go
// getCoins ...
func getCoins(method, endpoint string) (responeCoins ResponseCoins, err error) {
	client := &http.Client{}
	requestUrl, err := url.Parse(endpoint)
	if err != nil {
		return
	}
	req, err := http.NewRequest(method, requestUrl.String(), nil)
	if err != nil {
		return
	}
	req.Header.Add("Content-Type", "application/json")

	res, err := client.Do(req)
	if err != nil {
		return
	}
	defer res.Body.Close()

	coins := []Coin{}
	if err = json.NewDecoder(res.Body).Decode(&coins); err != nil {
		return
	}
	responeCoins.Coins = coins
	responeCoins.Source = "API"

	return
}
```

En este punto nuestro archivo `main.go` se encuentra as√±i y nuestra funci√≥n main haciendo una llamada al metodo `getCoins`

```go
// vars & structs
...

func main() {
	url := fmt.Sprintf("%s/%s/%s", urlBase, urlVersion, resourceCoinList)
	fmt.Println("Fetching all coins from: ", url)

	start := time.Now()
	// call getCoins
	resp, err := getCoins("GET", url)
	if err != nil {
		log.Fatal(err)
	}
	elapsed := time.Since(start)
	resp.ResponseTime = elapsed.String()

    fmt.Printf("Fetched [%d] coins from source: %s in response time: %s\n", len(resp.Coins), resp.Source, resp.ResponseTime)
}

...
// methods
```

Una vez q ejecutamos nuestro fichero `main.go` a trav√©s de la terminal de lineas de comando el resultado arrojado es el siguiente

```bash
‚ùØ go run main.go 
Fetching all coins from:  https://api.coingecko.com/api/v3/coins/list
Fetched [10324] coins from source: API in response time: 690.43916ms
```

### Crear conexi√≥n a redis

En esta parte crearemos un cliente de conexi√≥n a redis siguiendo la documentaci√≥n que nos provee el paquete [go-redis](https://github.com/go-redis/redis).

```go
func GetRedisDbClient(ctx context.Context) *redis.Client {

	clientInstance := redis.NewClient(&redis.Options{
		Addr:         os.Getenv("REDIS_URI"),
		Username:     "",
		Password:     os.Getenv("REDIS_PASS"),
		DB:           0,
		DialTimeout:  60 * time.Second,
		ReadTimeout:  60 * time.Second,
		WriteTimeout: 60 * time.Second,
	})

	_, err := clientInstance.Ping(context.TODO()).Result()
	if err != nil {
		log.Fatal(err)
	}

	return clientInstance
}

```

Con nuestra implementaci√≥n de nuestro m√©todo para la conexi√≥n a la base de datos redis procedemos al paso mas importante de este tutorial, y es aplicar la estrategia de *caching* de nuestra respuesta proveniente de la API. As√≠ es como quedar√≠a nuestro m√©todo `getCoins` usando nuestra instancia de redis

```go
// getCoins ...
func getCoins(
	ctx context.Context,
	rdb *redis.Client,
	method, endpoint, key string,
	duration time.Duration,
) (responeCoins ResponseCoins, err error) {

	result, err := rdb.Get(ctx, key).Result()
	if err == redis.Nil {
		log.Println("key not found:", err)
	} else if err != nil {
		return
	}

	if result != "" {
		err = json.Unmarshal([]byte(result), &responeCoins)
		if err != nil {
			return
		}
		responeCoins.Source = "cache"
		return responeCoins, nil
	}
    ...

	responeCoins.Coins = coins
	responeCoins.Source = "API"
	err = rdb.Set(ctx, key, responeCoins.ToJSON(), duration).Err()
	if err != nil {
		return
	}
	return
}

```

Como podemos observar en el m√©todo, se refactoriz√≥ la firma de nuestra funci√≥n para que aceptara por parametros nuesvos campos como nuestra instacia del cliente de redis, el contexto el cual es usado en todos los m√©todos de la liberia `go-redis`, se agreg√≥ adem√°s la key por la cual chequearemos la entrada de nuevos registro hacia la base de datos y como valor agregado un parametro `duration` para almacenar nuestra clave con un *TTL*.

Puede que resulte curioso el m√©todo `ToJSON` de la variable `responseCoins` este m√©todo convierte nuestra estructura a un objeto json dentro de un string. Para que pueda ser insertado en redis como valor de nuestra key ***key:value***. Es valido recalcar que en este tutorial estamos utilizado el tipo de dato m√°s bas√≠co que nos ofrece la base de datos redis que es `String`.

```go
// ToJSON ...
func (r *ResponseCoins) ToJSON() string {
	bytes, err := json.Marshal(r)
	if err != nil {
		log.Fatalf(err.Error())
	}
	return string(bytes)
}
```

En este punto revisando nuestro m√©todo main quedar√≠a con la siguiente estructura

```go
	...
	rdb := GetRedisDbClient(context.Background())
	...
	resp, err := getCoins(
		context.Background(),
		rdb,
		"GET",
		url,
		"coins:list",
		10*time.Second,
	)
	if err != nil {
		log.Fatal(err)
	}
    ...
```

Si ejecutamos una vez mas nuestro programa de go este ser√≠a el resultado:

```bash
REDIS_URI="localhost:6379" REDIS_PASS=password go run main.go

Fetching all coins from:  https://api.coingecko.com/api/v3/coins/list
Fetched [10326] coins from source: cach√© in response time: 18.048576ms
```

Y como se puede apreciar tenemos un tiempo de respuesta de unos 18ms. Pues s√≠ ha sido genial en este punto del tutorial observar como mejora el `performance` de nuestra llamada al m√©todo `getCoins` a trav√©s de nuestra estrategia de cach√©. Esto impacta de forma positiva en nuestros usuarios y en el uso de nuestras aplicaciones ya que de forma eficiente accedemos mucho mas r√°pido a nuestra informaci√≥n.

#### Conclusi√≥n

A trav√©s de este tutorial, pudimos desarrollar una aplicaci√≥n en el lenguaje de programaci√≥n go y nuestra base de datos Redis. Definimos una estrategia de Cach√© para consultar nuestra lista de monedas sin afectar el servicio de tercero que en lo particular nos ofrece un `rate limit` üõë de  ` 50 calls/minute`.  En nuestro caso de uso pudimos mejorar el tiempo de respuesta de nuestra aplicaci√≥n impactando en el `performance` de la misma adem√°s de ahorrar nuestras presiadas 49 llamadas restantes a nuestra `API` üòÇ.


#### Recursos

- [Caching API Responses with Redis and Nodejs](https://www.youtube.com/watch?v=ztLsihiCHic)
- [Go redis client](https://github.com/go-redis/redis)
- [Swagger JSON API Documentation](https://www.coingecko.com/api/documentations/v3/swagger.json)
- [Branding assets](https://www.coingecko.com/es/branding)
- [CoinGecko API Token List](https://docs.google.com/spreadsheets/d/1wTTuxXt8n9q7C4NDXqQpI3wpKu1_5bGVmP9Xz0XGSyU/edit#gid=0)

### C√≥digo del proyecto

[Aqu√≠ tienes el repositorio en **GitHub**](https://github.com/kenriortega/app-redis-for-blog) con todo el c√≥digo utilizado en el art√≠culo. Por si quieres revisarlo.


