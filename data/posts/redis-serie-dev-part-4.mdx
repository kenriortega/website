---

title: 'Redis como br√≥ker de mensajer√≠a?'

date: '2021-11-26'
tags:
  - 'üíª Development'
  - 'Redis'
  - 'Golang'
  - 'Message Broker'
---

Los br√≥kers de mensajer√≠a permiten desacoplar el intercambio de mensajes entre las aplicaciones, haciendo uso de patrones (*Pub/Sub* | *Queue*). Son tecnolog√≠as que est√°n dedicadas a procesar e intercambiar mensajes de datos entre aplicaciones, haciendo de mediador entre las mismas. Entre sus caracter√≠sticas podemos destacar:

- Enrutan los mensajes.
- Desacoplan los productores de mensajes de los consumidores.
- Organizan y comprueban los mensajes.
- Almacenan los mensajes.
- Presentan diversos patrones de mensajer√≠a (Colas de mensajes *Queue* y publicador-suscriptor *Pub/Sub*).
- Las colas de mensajes ofrecen mejor oportunidad para escalar el procesamiento.
- El *pub/sub* permite transmitir eventos de forma as√≠ncrona.

Entre los m√°s usados podemos nombrar [Apache Kafka](https://kafka.apache.org/) y [RabbitMQ](https://www.rabbitmq.com/). De estos dos existe mucha documentaci√≥n y cursos online que puede ser consultada en sus sitios oficiales.

El d√≠a de hoy estaremos hablando sobre un tipo de dato que tiene implementado redis a partir de su version 5.0. Este tipo de dato es llamado [Redis Stream](https://redis.io/topics/streams-intro).

El tipo de datos *stream* es para realizar operaciones de anexo de datos. El cual pude ser comparado con un registro de eventos en un fichero *log*, al menos conceptualmente. En este caso *redis Stream* implementa operaciones m√°s complejas para superar las limitaciones de los archivos *logs*.

*Redis stream* implementa caracter√≠sticas que lo hacen super interesantes:

- Presenta un conjunto de operaciones de bloqueo que permiten que los consumidores puedan esperar nuevos datos agregados a un flujo por los productores.
- Adem√°s del concepto llamado Grupos de consumidores como *apache Kafka*.

> Redis reimplementa una idea similar en los Grupos de consumidores como *apache Kafka*, lo que en t√©rminos completamente diferentes, pero el objetivo es el mismo: permitir que un grupo de clientes coopere consumiendo una porci√≥n diferente del mismo flujo de mensajes.

Teniendo esta breve explicaci√≥n espero que est√©s motivado en usar esta caracter√≠stica, como s√≠ estuvi√©semos usando *apache kafka*. Para m√°s detalles te√≥ricos y ejemplos de los comandos utilizados en este tutorial puedes revisar el apartado de recursos.

Realizando una üîç en *github* de posibles fuentes de inspiraci√≥n sobre el tema en cuesti√≥n, encontr√© el siguiente proyecto [Helsinki Transit System - Real-Time Vehicle üöç Tracking with Redis](https://github.com/redis-developer/expert-garbanzo) el cual fue lanzado en la *Redis 2021 Hackathon*, este cuenta con una excelente implementaci√≥n en go y redis, donde se hace uso de los tipos de datos *redis stream, pub/sub y timeseries* trabajando con un dataset en ***tiempo real***.

El d√≠a de hoy teniendo como base este genial proyecto, vamos a realizar una reimplementaci√≥n para el env√≠o de eventos, provenientes  de los üöç de transporte municipal hacia nuestra instancia *redis*.

### ‚öôÔ∏è Configuraci√≥n inicial de nuestro proyecto

En este caso usaremos *redis*, la cual es una imagen de docker configurada con esta funcionalidad.

```bash
# Download image
podman pull redislabs/redis:latest
# Run the container for our redis instance
podman run --name redis --rm -e ALLOW_EMPTY_PASSWORD=yes -p 6379:6379 redislabs/redis:latest
```
Nuestro repositorio de ejemplo cuenta con todos los ficheros necesarios para seguir este tutorial. Este es el estado actual de las carpetas.


```bash
‚îú‚îÄ‚îÄ data
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ pizzas.csv
‚îú‚îÄ‚îÄ examples
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cacheapp
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.go
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ minibroker ‚ú®
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ consumer
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.go
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ domain
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vp.go
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ producer
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ cmd
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ producer.go
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ main.go
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ minisearch
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ domain
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pizza.go
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ pizzasearch.go
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ handlers
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ handlers.go
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ http.rest
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.go
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ratelimit
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ http.rest
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ makefile
‚îú‚îÄ‚îÄ pkg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ db
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ redis.go
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ httpsrv
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ httpsrv.go
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mq
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ mqtt.go
‚îî‚îÄ‚îÄ README.md
```
Como se üëÄ tenemos un nuevo proyecto llamado `minibroker`, aqu√≠ se encuentran alojados nuestros servicios y ser√° el centro de esta aventura. La idea final de este tutorial es entender como enviar datos a trav√©s de *redis stream* y como consumir esos datos siguiendo el patr√≥n *producer/consumer*

### üßë‚Äçüè´ Explicaci√≥n del proyecto

El proyecto `minibroker` est√° compuesto por dos funcionalidades:

- Productor de eventos (*producer*)
- Consumidor de eventos (*consumer*)

#### üöá Productor de eventos

La primera funcionalidad üéÅ que estaremos explicando tiene como objetivo subscribirse a nuestra fuente de datos en tiempo real [High-frequency positioning](https://digitransit.fi/en/developers/apis/4-realtime-api/vehicle-positions/) a trav√©s de un protocolo de mensajer√≠a llamado [mqtt](https://mqtt.org/) m√°s detalles en la descripci√≥n de su sitio oficial.

```go
func main() {
  // init project
	ctx := context.Background()
	rdb := db.GetRedisDbClient(context.Background())

  //  signal control
	quitChannel := make(chan os.Signal, 1)
  // init mqtt client
	msgBroker := mq.NewMsgBroker(1024)
	mq.InitMQTTClient(msgBroker)

	// logic for mqtt sub -> send data to redis stream
	for i := 0; i < nWorkers; i++ {
		go cmd.SendData(ctx, msgBroker.StagingC, rdb)
	}

	signal.Notify(quitChannel, syscall.SIGINT, syscall.SIGTERM)
	<-quitChannel
}
```
La funci√≥n `main` esta compuesta por la instancia de nuestro client *mqtt*, el cual una vez subscrito es capaz de recolectar la informaci√≥n retornando en un  [`channel`](https://golangdocs.com/channels-in-golang) de tipo `<-chan []byte` el cuerpo del mensaje. Los m√©todos `NewMsgBroker` y `InitMQTTClient` forman parte de un nuevo paquete dentro de nuestro proyecto llamado `mq` el cual se encuentra en la ruta `pkg/mq/mqtt.go` este paquete fue confeccionado siguiendo el proyecto base, haciendo uso de la liberer√≠a de terceros [github.com/eclipse/paho.mqtt.golang](https://github.com/eclipse/paho.mqtt.golang). Una vez obtenido el mensaje este es pasado por par√°metro a la funci√≥n `SendData`.

```go
func SendData(ctx context.Context, payload <-chan []byte, client *redis.Client) {

	for msg := range payload {

		// Receive the content of the MQTT message and de-serialize bytes into
		// struct
		e := &domain.EventHolder{}
		err := mq.DeserializeMQTTBody(msg, e)

		if err != nil {
			log.Println(err)
			continue
		}

		pipe := client.TxPipeline()
		// // 2. XADD the full event body to a stream of events, these
		value, err := e.VP.ToMAP()
		if err != nil {
			log.Fatal(err)
		}
		pipe.XAdd(
			ctx, &redis.XAddArgs{
				Stream: "events:vp:bus",
				Values: value,
			},
		)
		// Execute Pipe!
		_, err = pipe.Exec(ctx)
		// Failed to Write an Event
		if err != nil {
			log.Fatal(err)
		}
	}
}
```
La funci√≥n `SendData` adem√°s de leer los mensajes provenientes del servicio de `mqtt` y parsear esa informaci√≥n, es la encargada de realizar la conexi√≥n con la instancia de redis, y de ejecutar el comando *XADD* permitiendo insertar los eventos dentro de *redis Stream*.

> üìå Una pr√°ctica com√∫n es enviar tipos de datos como `hash map` o `string` en nuestro tipo de datos stream.

```go
    ...
		value, err := e.VP.ToMAP()
		if err != nil {
			log.Fatal(err)
		}
		pipe.XAdd(
			ctx, &redis.XAddArgs{
				Stream: "events:vp:bus",
				Values: value,
			},
		)
    ...
```
En el fragemento de c√≥digo anterior se encuentra implementado en go del comando *XADD*, este recibe por par√°metros un `redis.XAddArgs` entre sus propiedades b√°sicas y de inter√©s para este tutorial se destacan `Stream` contiene el nombre del t√≥pico por donde se emitir√°n los eventos y `Value` hace menci√≥n a la data que se transmitir√°.

#### üöá Consumidor de eventos


La segunda funcionalidad üéÅ que estaremos explicando tiene como objetivo subscribirse a nuestra instancia de redis. Para llevar a cabo esta misi√≥n es necesario definir el nombre del t√≥pico que se consumir√° en nuestro caso `events:vp:bus` y para hacer uso de las funcionalidades que provee los Grupos de consumidores definir nuestro nombre.

```go

func main() {
	ctx := context.Background()
	rdb := db.GetRedisDbClient(context.Background())

	// define stream and consumer groups names
	streams := []string{"events:vp:bus"}
	var ids []string
	if groupName == "" {
		groupName = "consumer-" + StringWithCharset()
	}
	for _, v := range streams {
		ids = append(ids, ">")
		err := rdb.XGroupCreate(ctx, v, groupName, "0").Err()
		if err != nil {
			log.Println(err)
		}

	}
  	// for each stream it requires an '>' :{"events:vp:bus", ">"}
	streams = append(streams, ids...)
	fmt.Printf("Consumer gruop with name: [%s]\n", groupName)

	// subscribe to all streams
	for {
		entries, err := rdb.XReadGroup(ctx, &redis.XReadGroupArgs{
			Group:    groupName,
			Consumer: fmt.Sprintf("%d", time.Now().UnixNano()),
			Streams:  streams,
			Count:    2,
			Block:    0,
			NoAck:    false,
		}).Result()
		if err != nil {
			log.Fatal(err)
		}

		// excute func
		for _, stream := range entries {
			ReceiveMSG(ctx, stream, rdb, groupName)
		}

	}
}
```
La funci√≥n `main` esta compuesta por 2 fases:

- La fase inicial es la encargada de construir de forma din√°mica nuestros t√≥picos y nombres de grupos de consumidores permitiendo crear nuestro `XGroupCreate`.
- La segunda fase es la encargada de registrar el grupo de consumidor y de leer los t√≥picos definidos con la funci√≥n `XReadGroup`, dando paso a procesar todos los `streams`(t√≥picos).

```go

func ReceiveMSG(
  ctx context.Context,
  stream redis.XStream,
  rdb *redis.Client,
  groupName string,
) {
	for i := 0; i < len(stream.Messages); i++ {
		messageID := stream.Messages[i].ID
		values := stream.Messages[i].Values
		bytes, err := json.Marshal(values)
		if err != nil {
			log.Fatal(err)
		}

		rdb.XAck(
			ctx,
			stream.Stream,
			groupName,
			messageID,
		)

		fmt.Printf("ConsumerGroup: [%s] data : %s\n", groupName, string(bytes))
	}
}
```

En este punto de la funci√≥n `main` nos encontramos `ReceiveMSG` esta recibe una estructura de datos `redis.XStream` la cual contiene el mensaje proveniente de ese t√≥pico. En nuestro caso solo lo estamos imprimiendo por la terminal de l√≠neas de comandos. Existen otros casos de usos donde se podr√≠a hacer uso m√°s detallado de este proceso como un env√≠o de notificaciones hacia diversas plataformas, o seguir generando pipelines de procesamiento de datos como [Helsinki Transit System - Real-Time Vehicle Tracking with Redis](https://github.com/redis-developer/expert-garbanzo) proyecto de base de este turorial.


#### DEMO

![requests](/redis/redis-stream.gif)

#### Conclusi√≥n

- A trav√©s de este tutorial, pudimos desarrollar una aplicaci√≥n en go y redis, donde abordamos conceptos propios de la base de datos, como el uso de los `streams` tipo de dato muy potente que permite que nuestra instancia de redis pueda ser utilizada como br√≥ker de mensajer√≠a.
- Se pudo utilizar una liber√≠a nueva para consumir informaci√≥n proveniente de [github.com/eclipse/paho.mqtt.golang](https://github.com/eclipse/paho.mqtt.golang).
- Se abordaron conceptos referentes a sistemas de alto impacto relacionados con las colas de mensajes y comunicaci√≥n as√≠ncrona en el envio de eventos.

#### Recursos

- [Redis Stream](https://redis.io/topics/streams-intro)
- [Digitransit](https://digitransit.fi/en/developers/apis/4-realtime-api/vehicle-positions/)
- [Helsinki Transit System - Real-Time Vehicle Tracking with Redis](https://github.com/redis-developer/expert-garbanzo)


### C√≥digo del proyecto

[Aqu√≠ tienes el repositorio en **GitHub**](https://github.com/kenriortega/app-redis-for-blog) con todo el c√≥digo utilizado en el art√≠culo. Por si quieres revisarlo.


